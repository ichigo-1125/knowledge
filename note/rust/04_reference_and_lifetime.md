# 参照とライフタイム


## 目次

- [参照と借用](#参照と借用)
- [参照の使い方](#参照の使い方)
	- [暗黙的な参照解決と参照の借用](#暗黙的な参照解決と参照の借用)
	- [参照の代入](#参照の代入)
	- [参照への参照](#参照への参照)
	- [ファットポインタ](#ファットポインタ)
- [ライフタイム](#ライフタイム)
	- [ローカル変数の借用](#ローカル変数の借用)
	- [ライフタイムのルール](#ライフタイムのルール)
	- [staticな生存期間](#staticな生存期間)
	- [共有と変更における生存期間](#共有と変更における生存期間)
	- [バッファの再確保における生存期間](#バッファの再確保における生存期間)
	- [構造体と生存期間](#構造体と生存期間)


## 参照と借用

Rustでは、値の所有者であるポインタがドロップされると参照先もドロップされる。Rustには所有権を持たないポインタ型である、**参照**がある。参照は参照先の値よりも長生きしてはいけないので、これを強調するためにRustではある値の参照を作ることを**借用**と呼ぶ。

関数に引数を渡す時に所有権を移動してしまうと、それ以降は引数に使った値が使えなくなってしまう（**値渡し**）。そのため、関数の引数として参照を用いるのが正しい場合も多い（**参照渡し**）。

参照には2種類ある。

- **共有参照**を用いると、参照先の値を読むことはできるが書き換えることはできない。ある値への共有参照は同時に複数持つことができる。
- **可変参照**を用いると、参照先の値を読んだり書き換えたりすることができる。ある値に対する可変参照と他の参照（共有参照も可変参照も）を同時に使用することはできない。

```rust
//	show()は値を読んでいるだけなので、共有参照を取るようにすれば十分
fn show( table: &Table )
{
	//	コレクション型に対して繰り返し実行すると、普通は所有権が移動されて値が消費されてしまう
	//	共有参照に対して繰り返し実行すると、個々のエントリのキーと値に対する共有参照が作られる
	for (key, values) in table
	{
		println!("key = {}:", key);

		for value in values
		{
			println(" {}", value);
		}
	}
}

//	sort()は値を書き換えるので、可変参照を取る必要がある
fn sort( table: &mut Table )
{
	for(_key, values) in table
	{
		values.sort();
	}
}
```


## 参照の使い方

### 暗黙的な参照解決と参照の借用

Rustでは、 `&` 演算子によって参照を明示的に作り、 `*` 演算子で参照解決を行う。また、 `.` 演算子が必要に応じて暗黙に左側のオペランドを参照解決する。さらに、 `.` 演算子は必要であれば暗黙に左オペランドへの参照を借用する。

```rust
//	.演算子による暗黙的な参照解決
struct Book
{
	name: &'static str,
	published: bool,
}
let book = Book { name: "my book", published: false };
let book_ref = &book;
assert_eq!(book_ref.name, "my book");      //assert_eq!((*book_ref).name, "my book");

//	.演算子による暗黙的な参照の借用
let mut v = vec![5, 1, 4, 2, 3];
v.sort();     // (&mut v).sort();
```

### 参照の代入

変数に参照を代入すると、その変数は新しい場所を指すようになる。下記のようなコードを書いた場合、参照 `r` は最初 `x` を指しているが、代入後は `y` を指すようになる。C++ではこのような書き方をすると、暗黙的に参照解決が行われてしまい、 `r` が指し示す先に `y` のポインタが代入されるという挙動になり、これは明らかに直感に反している。

```rust
let x = 10;
let y = 20;
let mut r = &x;
r = &y;
```

### 参照への参照

Rustは参照への参照を許しており、 `.` 演算子は方をチェックして何段でも参照解決を行ってくれる。

```rust
struct Position
{
	x: usize,
	y: usize,
}
let position = Position { x: 100, y: 200 };
let r = &position;
let rr = &r;
let rrr = &rr;

assert_eq!(rrr.y, 200); ```

### ファットポインタ

Rustには2種類の**ファットポインタ**がある。ひとつはスライスであり、もうひとつは特定のトレイトを実装した値への参照である**トレイトオブジェクト**である。トレイトオブジェクトは、値のアドレスとその値に対応するトレイとの実装をもつファットポインタとなっている。


## ライフタイム

### ローカル変数の借用

ローカル変数の参照を借用して、その変数をスコープの外に持ち出すことはできない（**ダングリングポインタ**）。

```rust
{
	let r;
	{
		let x = 1;
		r = &x;
	}
	assert_eq!(*r, 1);     //	スコープの外ではxにアクセスできない
}
```

Rustにはこのダングリングポインタを防ぐための厳密なルールが存在している。

### ライフライムのルール

Rustコンパイラは、プログラム中のすべての参照型に対して、その参照の使われ方によって生じる制約を反映した**生存期間**（ライフタイム）を割り当てる。生存期間とは、プログラム実行中に参照が安全に利用できる期間を指す。コンパイラはこの生存期間を利用して、参照の安全性を保証する**ボローチェッカー**という機能を備えている。

生存期間のルールは以下のとおり。
- ある変数の参照は、その変数よりも長生きしてはならない。
- ある変数に格納した参照は、少なくともその変数と同じだけ生きていなければならない。（変数の生存期間は、その変数から借用した参照の生存期間を包含していなければならない）

また、Rustは変数の生存期間として可能な限り短い期間を想定する。

### staticな生存期間

あるstaticな変数を更新する以下のような関数を考える。

```rust
static mut STASH: &i32 = &128;

fn update( p: &i32 )
{
	unsafe
	{
		STASH = p;
	}
}
```

このとき、関数のシグネチャは**生存期間パラメータ**を省略している（実際はRustのコンパイラが自動的に保管してくれるので省略可能）。これを明示的に記述すると以下のようになる。

```rust
fn update<'a>( p: &'a i32 ) { /* ... */ }
```

`'a` は任意の生存期間であり、引数 `p` が任意の生存期間パラメータを持っていることを示す。しかし、static変数である `STASH` に対して任意の生存期間を持つ変数 `p` を代入するのは、生存期間のルールに反している（変数 `p` は少なくとも `STASH` と同じだけの生存期間を持たなければならない）。そこで、関数の引数として取りうる値の生存期間を**'static生存期間**にすることでこの問題を解決できる。

```rust
fn update( p: &'static i32 ) { /* ... */ }
```

このようにRustでは、関数のシグネチャを見るだけでその関数が引数をその関数を呼び出したスコープを超え他場所に隠すかどうかがわかる。

### 共有と変更における生存期間

生存期間の制約により、参照がスコープから外れた変数を指すことがないことは保証されている。次の例は、ダングリングポインタが発生する別のケースである。

```rust
let v = vec![1, 2, 3, 4, 5];
let r = &v;
let aside = v;    //	ここで移動が発生する
r[0];             //	未初期化状態となったvを使用しようとしている
```

当然Rustではこのようなプログラムはエラーとなる。 `v` の参照である `r` の生存期間が、 `v` の生存期間よりも長くなってはいけないからだ。

### バッファの再確保における生存期間

ベクタにおいて、その変数のもともとの容量を超える要素が加えられようとするとき、ベクタはより容量の大きいバッファを再確保しようとする。このバッファの再確保によりダングリングポインタが発生する例が次のプログラムだ。

```rust
//	他のスライスによってベクタを拡張する関数
fn extend( vec: &mut Vec<f32>, slice: &[f32] )
{
	for elem in slice
	{
		vec.push(*elem);
	}
}

let mut wave = Vec::new();
let head = vec![0.0, 1.0];
let tail = [0.0, -1.0];

extend(&mut wave, &head);
extend(&mut wave, &head);

//	ここでバッファの再確保が起きるとする
extend(&mut wave, &wave);
```

最後の `extend()` 呼び出し時にバッファの再確保が起きると、第2引数で渡されたスライスの参照先がなくなってしまう。しかし、Rustの参照のルールにより、 `wave` の可変参照と共有参照を同時に作ることはできない。これは言い換えると、可変参照の生存期間は他のいかなる参照の生存期間とも重なってはいけない、と説明できる。

### 構造体と生存期間

構造体が参照を含む場合、参照の生存期間を指定する必要がある。次の例では、任意の生存期間 `<'elt>` に対して、生存期間が `<'elt>` である参照を保持する構造体を定義している。

```rust
struct Extrema<'elt>
{
	greatest: &'elt i32,
	least: &'elt i32,
}

fn find_extrema<'s>( slice: &'s [i32] ) -> Extrema<'s>
{
	let mut greatest = &slice[0];
	let mut least = &slice[0];

	for i in 1..slice.len()
	{
		if slice[i] > *greatest { greatest = &slice[i]; }
		if slice[i] < *least { least = &slice[i]; }
	}
	Extrema { greatest, least }
}
```
