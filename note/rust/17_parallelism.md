# 並列性


## 目次

- [マルチスレッドプログラミング](#マルチスレッドプログラミング)
- [フォークジョイン並列](#フォークジョイン並列)
- [チャネル](#チャネル)
	- [スレッド安全](#スレッド安全)
- [可変状態の共有](#可変状態の共有)
	- [排他ロック](#排他ロック)
	- [Mutex](#mutex)
	- [デッドロック](#デッドロック)


## マルチスレッドプログラミング

マルチスレッドプログラミングにおけるイディオムには次のようなものがある。

- **バックグラウンドスレッド**: 1つだけ仕事を持っており、定期的に起きてその仕事を行う。
- **汎用ワーカプール**: クライアントと**タスクキュー**で通信する。
- **パイプライン**: データはパイプラインを通じてあるスレッドから次のスレッドへ流れていく。
- **データ並列**: コンピュータ全体が1つの大きな計算だけを主に行っているときに、その計算をn個に分割してn個のスレッド実行する。
- **同期オブジェクトの海**: 複数のスレッドが同じデータにアクセスすることが許されており、**排他ロック**のような低レベルのプリミティブを用いたアドホックな**ロック**でデータ競合を回避する。
- **アトミックな整数処理**: 複数のコアが機械依存の1ワード長のフィールドを通して情報を渡すことを通信で行う。


## フォークジョイン並列

**フォークジョイン並列**では、複数の完全に独立したタスクを一度に実行する。**フォーク**は新しいスレッドを起動すること、**ジョイン**は1つのスレッドが終了するのを待つことを意味する。

フォークジョイン並列では共有資源をロックすることはなく、ボトルネックがない。また、タスクスイッチのオーバーヘッドも小さい。理想的な場合を考えれば、性能はシングルスレッドの場合に比べてスレッド数の分だけ時間が短くなるので、性能の計算が容易である。ただし、スレッドが均等にタスクを分散できない可能性や、スレッドがジョインした際にその計算結果を統合しなければいけないことを考慮しなければならない。

複数のスレッド間で不変データを共有する場合、Arcを用いるとよい。


## チャネル

**チャネル**は、あるスレッドから空別のスレッドに値を送信する一方通行のパイプである。チャネルを用いると、ロックや共有メモリを使わずにスレッド間で値を相互に渡すことができる。

### スレッド安全

スレッド間で安全に受け渡し可能な型には、SendやSyncといったマーカートレイとが実装されている。Sendを実装している型は他のスレッドに値を渡しても安全である。Syncを実装する型は他のスレッドに非mut参照で渡しても安全である。Syncを実装している型はすべてSendも実装している。


## 可変状態の共有

### 排他ロック

**排他ロック**は、複数のスレッドがあるデータにアクセスする際に、同時ではなく順番にアクセスすることを強制するために用いられる。

### Mutex

Mutexはロックを獲得するための手段である。

```rust
use std::sync::Arc;

struct App
{
	waiting_list: Mutex<WaitingList>,
	/* ... */
}

let app = Arc::new(App
{
	wating_list: Mutex::new(vec![]),
});
```

### デッドロック

すでに保有しているロックを再度取りに行くと**デッドロック**する。

```rust
let mut guard1 = self.waiting_list.lock().unwrap();
let mut guard2 = self.waiting_list.lock().unwrap();   //	デッドロック
```
