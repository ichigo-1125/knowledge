# 式


## 目次

- [式言語](#式言語)
	- [ブロックと値](#ブロックと値)
- [変数宣言](#変数宣言)
- [代入](#代入)
- [ifとmatch](#ifとmatch)
- [if let式](#iflet式)
- [ループ](#ループ)
	- [ループ内の制御フロー](#ループ内の制御フロー)
- [return式](#return式)
- [関数呼び出しとメソッド呼び出し](#関数呼び出しとメソッド呼び出し)
- [フィールドと要素](#フィールドと要素)
- [参照演算子](#参照演算子)
- [二項演算子](#二項演算子)
- [型キャスト](#型キャスト)


## 式言語

プログラミング言語によっては、**式**と**文**が厳密に区別されている。式には値があるが、文にはない。Rustは**式言語**のひとつであり、すべてを式で行う。

Rustでは、 `if` や `match` といった制御構文も式であり、値を作ることができる。そのため、これらを変数の初期化に使うこともできる。これがRustに三項演算子がない理由である。

### ブロックと値

ブロックも式であるので、値を生み出すことができる。Rustでは、ブロックの最後の行にセミコロンをつけなければ、それがブロックの値として使われる。


## 変数宣言

Rustでローカル変数を新しく作るには、 `let` 宣言を用いる。同じ変数名の変数を再度宣言すると、新たに同名の変数を作り、もとの変数を置き換える（別の型でもよい）。このような書き方を**シャドーイング**という。

```rust
let name: type = expr;
```


## 代入

Rustの変数はデフォルトでイミュータブルなため、他の言語よりも代入の機会は少ない。

Rustでは**複合代入**はサポートされているが、インクリメント演算子とデクリメント演算子はサポートされていない。

```rust
let total += item.price;   //	複合代入
```


## ifとmatch

if式は他のプログラミング言語と変わらない。ただし、Rustでは条件が必ずbool型の式である必要がある（Rustが数値や文字列を暗黙的に真偽値に変換することはない）。

```rust
if condition1 { /* ... */ }
else if condition2 { /* ... */ }
else { /* ... */ }
```

match式は、C言語などのswitch文と似ているが、より柔軟である。パターンとして整数値だけでなく、 `Optioin` 値なども区別することができるからだ。パターンは、 `value` が取りうるすべてのケースをカバーしている必要がある。

```rust
match value
{
	pattern1 => expr,
	pattern2 => expr,
	_ => epxr,
}
```

if式もmatch式も、すべてのブロック（パターン）が同じ型の値を返さなければならない。


## if let式

if let式は、与えられた `expr` が `pattern` にマッチするなら最初のブロックが、マッチしなければ後ろのブロックが実行される。これは、 `Option` や `Result` から値を取り出すのに便利な、match式の省略形である。

```rust
if let pattern = expr { /* ... */ } else { /* ... */ }
```


## ループ

Rustには4つのループ式がある。while式とfor式の値は常に `()` となる。while let式は、パターンマッチを条件にしてループ処理を実行することができる。loop式は無限ループを実行するためのもので、任意の値を返すことができる（ただし、返される値すべての型が同じでなければならない）。for式はイテレータの値を消費しながらループ処理を実行する。

```rust
while condition { /* ... */ }

while let pattern = expr { /* ... */ }

loop { /* ... */ }

for pattern in iterable { /* ... */ }
```

for文でイテレータの値を消費することなくループ処理を実行したい場合は、イテレータの参照に対してfor文を実行すればよい。

```rust
for elem in &iterable { /* ... */ }
```

### ループ内の制御フロー

break式を用いると、そのループブロックを抜けることができる。

```rust
loop
{
	break value;
}
```

continue式を用いると、そのループの次の回に飛ぶことができる。

ループに生存期間で**ラベル付け**することができる。

```rust
'outer
for author in authors
{
	for book in author.books
	{
		break 'outer;
	}
}
```


## return式

return式は現在の関数から脱出し、呼び出し元に値を返す。


## 関数呼び出しとメソッド呼び出し

Rustで関数やメソッドを呼び出す方法は他の多くの言語と同様である。

```rust
let x = func();                 //	関数呼び出し
let room = player.location();   //	メソッド呼び出し
let mut v = Vec::new();         //	型関連関数呼び出し（staticメソッドのようなもの）
```

Rustの関数呼び出しやメソッド呼び出しにおいては、 `Vec<T>` のような通常のジェネリック型の構文は使えない。これは、 `<` が比較演算子として解釈されてしまうからである。そこで、次のような**ターボフィッシュ**と呼ばれる記法を用いてジェネリック型であることをコンパイラに推論させる必要がある。

```rust
Vec<i32>::with_capacity(1000);      //	間違い
Vec::<i32>::with_capacity(1000);    //	ターボフィッシュを用いる
```

また、コンパイラが型を推論できるような場合にはこれらを省略するほうが良い。


## フィールドと要素

構造体のフィールドや、配列・スライス・ベクタの要素へのアクセスは、一般的な構文で行うことができる。.演算子や `[]` の左側の値は暗黙的に参照解決される。

```rust
company.fundation  //	 構造体のフィールドへのアクセス
goods.1            //	タプルのフィールドへのアクセス
pieces[i]          //	配列・スライス・ベクタの要素へのアクセス
```

これら3つの値は代入文の左辺に現れることができるので、**左辺値**と呼ばれる。


## 参照演算子

Rustでは.演算子がフィールドやメソッドにアクセスする際に暗黙的に参照解決を行うので、\*演算子により参照で指される値にアクセスする機会は少ない。


## 二項演算子

Rustの二項演算子（算術演算子、ビット演算子、比較演算子、論理演算子）は他の多くの言語と似ているので、特殊なケースを除けば問題なく扱える。


## 型キャスト

Rustでは通常、暗黙的な型変換が行われないので、明示的にキャストする必要がある。キャストにはasキーワードを用いる。

```rust
let x = 10;                //	xはi32型
let index = x as usize;    //	usizeに変換
```

基本的なキャストのルールは次の通り。

- 組み込み数値型の間ではキャストが可能。
- book型、char型、enum型から任意の整数型にはキャストが可能。逆方向へのキャストは不可。

また、Rustでは以下のような**参照解決型変換**が行われる。これは、組み込みトレイトの **Deref** を実装している型に適用される。

- 型&Stringの値は、型&strに自動変換される。
- 型&Vec<i32>の値は、&[i32]に自動変換される。
- 型&Box<Chessboard>の値は、&Chessboardに自動変換される。


## クロージャ

Rustには、軽量の関数のような値、**クロージャ**がある。

```rust
let is_even = | x | x % 2 == 0;               //	返り値の型を推論させた場合
let is_even = | x | -> bool { x % 2 == 0 };   //	返り値の型を明示的に書いた場合
```
