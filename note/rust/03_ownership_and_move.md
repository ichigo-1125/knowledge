# 所有権と移動


## 目次

- [メモリ管理](#メモリ管理)
- [所有権](#所有権)
- [移動](#移動)
	- [移動とインデックス参照される値](#移動とインデックス参照される値)
	- [コピー型](#コピー型)
	- [RcとArc](#rcとarc)


## メモリ管理

メモリ管理に関しては、プログラミング言語に次の2つの特徴があることが望ましい。

- メモリがプラグラマが選んだタイミングで適切に開放されること。これによりプログラムが消費するメモリを抑えることができる。
- 開放済みのオブジェクトへのポインタを使ってしまうことがないこと。これらは未定義動作になり、クラッシュやセキュリティホールにつながる。

これらの特徴は相反しており、ポインタが存在するうちに値を解放するとそのポインタの参照する先がなくなってしまう（このようなポインタを**ダングリングポインタ**という）。そのため、多くのプログラミング言語はこれらのうちどちらかを諦めており、トレードオフを選択する必要がある。

- 安全第一のプログラミング言語では、**ガベージコレクション**を用いてメモリ管理を行う。オブジェクトへ到達できるポインタがすべてなくなったところで、自動的にそのオブジェクトを解放する。Python、JavaScript、Java、C#、Haskellなどのほとんどの近代的な言語はこれに属する。ガベージコレクタを用いると、望んだタイミングでメモリが解放されなかったのかを理解するのが難しい。
- 制御優先のプログラミング言語では、メモリ解放の責任をプログラマに委ねる。ダングリングポインタを避ける責任もプログラマに課せられる。これは、プログラマがミスを侵さなければ良い方法である。これに属する言語はCとC++だけである。

Rustはポインタの使用に制約を加えたことで、これら2つの両立を実現している。


## 所有権

C++では、オブジェクトに所有されているメモリに対して一時的なポインタを作った際には、所有しているオブジェクトがそのメモリ領域を破棄するよりも前に、そのコードの責任でそのポインタを破棄する必要がある。

Rustでは、**所有権**は言語そのものに組み込まれており、コンパイル時のチェックによって強制される。すべての値はその**生存期間**を決定する唯一の所有者を持ち、所有者が解放（ドロップ）されたときに所有されていた値もドロップされる。

ベクタや文字列などの可変長の変数を扱う際には、その変数のポインタ、容量、長さを保持するワード列が**スタックフレーム**上に保持され、そのポインタの先のバッファだけが**ヒープ**上に取られる。このような状態を、バッファがスタックフレーム上のポインタに所有されているという。

複雑な所有関係にある要素（ベクタの中に文字列が格納されている場合など）では、所有者と所有される値は**ツリー構造**をなす。変数がスコープから外れると、ツリー全体がドロップされる。

Rustの所有権には他にも以下のような特徴がある。

- 値を1つの所有者から別の所有者へ**移動**することができる。
- 整数、浮動小数点、文字などの**プリミティブ型**（ヒープ上に領域を確保する必要のない、固定長の変数）については所有権のルールが適用されない。
- 標準ライブラリのRc、Arcを利用することで、**参照カウント**が利用できる。
- 値への「**参照の借用**」ができる。


## 移動

Rustではほとんどの型が、変数への値の代入、関数への引数の受け渡し、関数からの返り値の返却の際にコピーされずに**移動**（move）される。値が移動されると、もともとその値を所有していた変数は**未初期化状態**になる。

**ディープコピー**は高価な操作であるため、必要な場合は明示的に変数に対して `clone()` メソッドを呼ぶ。

Rustのコンパイラは、これらの移動を「見透かす」のが上手く、機械語レベルで見ると値が最終的に移動する場所にはじめからオブジェクトが作られることも多い。

### 移動とインデックス参照される値

ベクタのようなインデックスにより参照される値については、インデックスを指定してその要素だけを移動するということができない（どの要素が移動されたのかという情報を、値がドロップされるまで持ちまわらなければいけなくなるため）。このような操作を実現したい場合は次のような3つの方法がある。

```rust
let mut v = Vec::new();
for i in 1..100
{
	v.push(i.to_string());
}

//	1. ベクタの最後の要素をポップして取り出す
let x = v.pop().expect("vector empty");

//	2. ベクタの指定したインデックスの場所から要素を取り出し、代わりに最後の要素をそこに入れる
let index = 8;
let y = v.swap_remove(index);

//	3. 取り出した値の代わりに別の値を入れる。
let index = 10;
let z = std::mem::replace(&mut v[index], "substitute".to_string());
```

特に `Option<T>` を要素として持つベクタから値を取り出したい場合には、値を移動して変わりに `None` を入れるという使い方が多い。このために要塞れているのが `take()` メソッドである。

コレクション型は一般に、すべての要素をループで消費するためのメソッドを用意している。次のようにしてループにベクタを直接渡すと、ベクタは `v` から移動されて `v` は未初期化状態になり、繰り返しごとにループは新しい要素を変数 `s` に移動する。

```rust
let v = vec!["hello".to_string(), "world".to_string(), "rust".to_string()];

for mut s in v
{
	s.push('!');
	println("{}", s);
}
```

### コピー型

ヒープ領域のリソースを伴う値はコピーするのに大きなコストが必要になる。一方で、プリミティブ型のように移動を意識するメリットが少ない型については移動のルールが適用されない。このような型を**Copy型**と呼ぶ。

変数がCopy型であるかを判断する上で簡単な指標として、値をドロップする際になにか特別なことをしなければならない型はCopy型ではない。

独自定義の型についてはデフォルトではCopy型ではないものの、フィールドすべてがCopy型である場合には次のように属性を付与することでCopy型にすることができる。

```rust
#[derive(Copy, Clone)]
struct Size
{
	height: usize,
	width: usize,
}
```


### RcとArc

Rustでは値が唯一の所有者を持っているが、複数の所有者のすべてがその値を使い終わるまで生きてほしいような値に対しては、**Rc**や**Arc**といった**参照カウント**のポインタ型を利用することができる。

Arcは**アトミックな参照カウント**であり、複数のスレッド間で値を直接共有しても安全なようにできている。ただし、そのような必要がない場合にはRcの方が高速である。

```rust
use std::rc::Rc;

let s: Rc<String> = Rc::new("hello, world".to_string());
let t: Rc<String> = s.clone();
let u: Rc<String> = s.clone();
```

このようなコードを書いた場合、スタックフレーム上ではヒープ領域のRcの参照カウントを指すポインタだけが保持される。Rcは**強い参照カウント**を持ち、 `Rc<T>` がクローンされると参照カウントがインクリメントされる。Rc自身はString型と同様に、値へのポインタとバッファの容量と値の長さからなるワード列でできている。

Rcポインタに所有される値は普遍となるので注意が必要。Rustのメモリ安全性とスレッド安全性は、ある値が、共有されていると同時に可変にはならないことに依存している。
