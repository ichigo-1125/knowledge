# Rustの基本的なデータ型


## 目次

- [Rustの型システム](#rustの型システム)
	- [型推論](#型推論)
	- [ジェネリック](#ジェネリック)
- [固定長数値](#固定長数値)
	- [整数](#整数)
	- [浮動小数点](#浮動小数点)
	- [チェック付き演算](#チェック付き演算)
	- [ラップ演算](#ラップ演算)
	- [飽和演算](#飽和演算)
	- [オーバーフロー演算](#オーバーフロー演算)
- [真偽値型](#真偽値型)
- [文字](#文字)
- [タプル](#タプル)
- [ポインタ型](#ポインタ型)
	- [参照](#参照)
	- [Box](#box)
	- [rawポインタ](#rawポインタ)
- [配列](#配列)
- [ベクタ](#ベクタ)
- [スライス](#スライス)
- [文字列型](#文字列型)
	- [文字列リテラル](#文字列リテラル)
	- [バイトリテラル](#バイトリテラル)
	- [文字列](#文字列)
- [型エイリアス](#型エイリアス)


## Rustの型システム

Rustは**静的型付け言語**であり、JavaScriptやPythonといった**動的型付け言語**とは異なり、変数の型がコンパイル時に確定する。そのため、プログラム中の変数には明示的に型を示しておく必要があり、コードが煩雑になってしまう傾向がある。また、型を確定させてしまうことで、関数などの汎用性が低下してしまうというデメリットもある。

Rustではこれらのデメリットを解消するために、型推論とジェネリックという機能を有している。

### 型推論

Rustコンパイラには**型推論**の機構があり、プログラム中に明示されたいくつかの型情報を用いて、明示されていない変数の型を**推論**してくれる。これにより、コンパイル時のエラー検出というメリットを残したまま、動的型付け言語の可読性の高さという恩恵を受けることができる。

### ジェネリック

関数などを**ジェネリック**にすることで、1つの定義で様々なユースケースに対応することができるようになる。

JavaScriptやPythonといった動的型付け言語では、すべての関数が自然とこのような動作となる。関数が、その関数が必要とするプロパティやメソッドを持つすべてのオブジェクトを引数にとって動作することができるという性質を、**ダックタイピング**という。このような性質はプログラミングを効率化させる一方で、エラーの原因ともなってしまう。

Rustでは、ジェネリックの機構を利用することにより、厳密な型チェックと柔軟性を両立している。


## 固定長数値

Rustがサポートする**固定長数値型**は以下の通り。

| サイズ（ビット数） | 符号なし整数 | 符号付き整数 | 浮動小数点 |
| ------------------ | ------------ | ------------ | ---------- |
| 8                  | u8           | i8           |            |
| 16                 | u16          | i16          |            |
| 32                 | u32          | i32          | f32        |
| 64                 | u64          | i64          | f64        |
| 128                | u128         | i128         |            |
| 計算機のワード長   | usize        | isize        |            |

### 整数

Rustの符号付き整数は**2の補数表現**となっている。

Rustでは、**バイト値**に対して `u8` 型を用いる。バイナリファイルやソケットからデータを読み取ると、u8の値のストリームが得られる。

CやC++では数値と文字の型を区別しない（u8とcharは同じ）が、Rustではこれらを区別する。ただし、**バイトリテラル**というものが用意されており、例えば `b'X'`は、文字Xに対するASCIIコードの `u8` の値になる。

`usize` と `isize` 型は、実行対象計算機のアドレス空間サイズに依存しており、32ビットアーキテクチャでは32ビット、64ビットアーキテクチャでは64ビットとなる。

`0x` 、 `0o` 、 `0b` を冒頭につけると、それぞれ16進数、8進数、2進数の**リテラル**になる。

整数型から別の整数型への変換は、 `as` 演算子を用いて行う。RustはCやC++とは異なり、数値型の**暗黙の型変換**をほとんど行わないので、プログラマ自身が明示する必要がある。

### 浮動小数点

Rustは、IEEE標準準拠の**単精度**と**倍精度**の浮動小数点をサポートしている。そのため、 `f32` と `f64` はそれぞれIEEE規格が要求する型関連定数である、`INFINITY` 、 `NEG_INFINITY` 、 `NAN` 、 `MIN` と `MAX` を持つ。

### チェック付き演算

計算結果がオーバーフローした場合など、数学的に正しい答えが得られない場合の挙動を制御したい場合に用いる演算として、チェック付き演算やラップ演算、飽和演算、オーバーフロー演算などがある。

**チェック付き演算**では、結果を `Option` として返す。数学的に正しい答えが得られた場合には `Some(v)` を、そうでない場合には `None` を返す。

接頭辞 `check_` をつけてその後に演算子名を続けることで利用できる。

### ラップ演算

**ラップ演算**では、数学的に正しい答えを値の範囲で除算した余りを返す。

接頭辞 `wrapping_` をつけてその後に演算子名を続けることで利用できる。

### 飽和演算

**飽和演算**では、数ガキ的に正しい結果に対して、その方で表現できる最も近い値を返す（その型の最大値、最小値で**クランプ**した結果を返す）。

接頭辞 `saturating_` をつけてその後に演算子名を続けることで利用できる。

### オーバーフロー演算

**オーバーフロー演算**では、 `(result, overflowed)` という形のタプルを返す。 `result` はラップ演算で得られる値、 `overflowed` はオーバーフローが発生したかどうかの真偽値である。

接頭辞 `overflowing_` をつけてその後に演算子名を続けることで利用できる。


## 真偽値型

Rustの**真偽値型**である `bool` は、 `true` と `false` という2種類の値を持つ。プログラム中で行われる**比較演算**は、結果として真偽値型を生成する。

真偽値を表現するのに必要なメモリは1ビットであるが、Rustでは真偽値に対するポインタを作れるようにするため、1バイトをまるまる使用する。


## 文字

RustはUnicodeの1文字を表現するために32ビットの `char` 型を用いる（C++における `char` 型は1バイト=8ビットのASCII文字のみ扱える）。


## タプル

**タプル**は様々な型の組み合わせを表現するための型である。要素へのアクセスには定数のインデックスを用いる。

```rust
let profile: (&str, i32, i32) = ("ichigo", 2001, 20);
println!("{}", profile.1);
```

タプルは**配列**とよく似ているが、配列が同じ型の要素を複数保持できるのに対し、タプルは異なる肩の要素をまとめることができる。また、配列は変数インデックスによる要素へのアクセス（ `array[i]` ）ができるのに対して、タプルは定数インデックスしか用いることができない。

タプルは関数の返り値などに頻繁に用いられる。関数は1つしか値を返すことができないので、複数の値を返却したい場合はタプル型を利用する。

構造体にするほどでもない自明な値をまとめるときにもタプルを用いることが多い。例えば、 `(height, width)` や `(latitude, longitude)` などである。

0要素のタプルもタプルの典型的な活用例である。これは `()` のように記述され、**ユニット型**と呼ばれている。


## ポインタ型

Rustには、**ポインタアドレス**を表す型がいくつかある。

### 参照

**参照**はRustの最も基本的なポインタ型である。

`String` 型の値への参照は `&String`であり、これは `String` のアドレスを保持した1ワード長のデータとなる。

RustのポインタはCとは異なり、決して `null` になることがない。また、値の**所有権**と**生存期間**の管理により、**ダングリングポインタ**や**多重開放**（多重フリー）、**ポインタの無効化**といったバグはコンパイル時に取り除くことが可能である。

`&T` は変更不能な**共有参照**であり、ある値に対する共有参照は複数持つことができる。読み取り専用で、参照先の値は書き換えることができない。

`&mut T` は排他的な**可変参照**であり、ある値に対して他の共有参照も可変参照も持つことができない。参照先の値を読み出したり書き換えたりすることができる。

### Box

`Box` は**ヒープ**上に値を確保するために用いる。 `Box<T>` の値は、事前に**移動**（move）されていない限りはスコープを抜けると自動的にメモリが開放される。

### rawポインタ

**rawポインタ**はC++が扱うポインタとよく似ており、Rustが管理してくれるポインタとは異なって安全とは限らない（unsafe Rust)。


## 配列

**配列**はメモリ上に値の列を表現するための方法のひとつである。配列のサイズはコンパイル時に決定され、動的に新しい要素を追加したり縮小したりすることはできない。

```rust
let prime_number: [u32; 6] = [2, 3, 5, 7, 11, 13];
```

同じ値で配列を埋めたいときは、次のように書くことができる。この記法により、固定長バッファを初期化することもできる（下記の2つ目の例）。

```rust
let true_array = [true; 100];
let buff = [0u8; 1024];
```


## ベクタ

**ベクタ**はヒープ上に確保され、サイズを変更することができる配列である。

```rust
let mut fibonacci_number = vec![0, 1, 1, 2, 3, 5, 8];
fibonacci_number.push(13);
fibonacci_number.push(21);
```

配列と同様、同じ値でベクタを埋めて初期化することもできる。

```rust
let mut false_vec = vec![false; 100];
```

空のベクタの初期化は次のように書くこともできる。

```rust
let mut empty_vec = Vec::new();
```

ベクタは3ワード長のフレームで表現され、要素を保持しているヒープ上のバッファへのポインタ、バッファに保持できる容量、現在保持している要素数からなる。

バッファが容量の上限に達したときに新しい要素が追加されると、より大きなバッファが再度確保（アロケート）され中身がコピーされる。アロケートは処理に時間がかかってしまうため、事前に必要な容量がわかっている場合は十分な大きさを確保して初期化しておくのがよい。

```rust
let mut v = Vec::with_capacity(100);
```

ベクタの任意の位置に要素を挿入したり削除したりすることもできるが、これは要素すべてをシフトする必要があるため効率的ではない。このような操作が頻繁に行われる場合はベクタではなくリスト（LinkedList）を用いたほうがよい。


## スライス

**スライス**は、配列やベクタのある領域を指し、常に参照で表される。

スライスは**ファットポインタ**であり、スライスが指す最初の要素へのポインタとスライスに含まれる要素数という2ワード長で表される。

```rust
let even: [i32; 5] = [2, 4, 6, 8, 10];
let even_slice: &[i32] = &even;
```

通常の参照は、メモリ上の単独の値に対する所有権のないポインタであるのに対し、**スライスの参照**（あるいは単にスライス）はメモリ上の連続した値の領域に対する参照であると考えることができる。

同じ型のデータ列に対する関数を実装する際には、引数としてスライスを取るように設計すると、配列に対してもベクタに対しても適用できるようになる。

```rust
fn print_num( n: &[i32] )
{
	for elem in n
	{
		println!("{}", elem);
	}
}
```


## 文字列型

### 文字列リテラル

**文字列リテラル**はダブルクォーテーションで囲まれた文字列である。文字列リテラルには改行を含めることができ、文字列の行の最後にバックスラッシュをつけた場合は、改行文字と次の行の空白文字が無視される。

```rust
"Lorem ipsum dolor sit amet, consectetuer adipiscing elit.
Aenean commodo ligula eget dolor.
Aenean massa.
Cum sociis natoque penatibus et magnis dis parturient montes, \
nascetur ridiculus mus."
```

文字列中の意味のある文字を**エスケープ**するのが面倒な場合（Windowsのパスを記述するときなど）は、**生文字列**（raw string）を用いることができる。

```rust
r"C:\Program Files\App"
```

さらに、ダブルクォーテーションのエスケープすらも省略したい場合には、開始と終了のダブルクォーテーションを任意の数のハッシュ文字で挟む（ハッシュ文字の数は、わかりやすいように決めればよい）。

```rust
r###"She say "hello"."###
```

### バイトリテラル

文字列リテラルの冒頭に `b` をつけた場合は**バイトリテラル**となり、Unicodeテキストからのスライスではなく、 `u8` （バイト）値の列からのスライスとなる。

```rust
let method = b"GET";
```

バイトリテラルにはUnicode文字を含めることはできず、ASCII文字とエスケープシーケンスのみを含むことができる。

### 文字列

Rustの文字列はUnicodeの文字の列となっており、これはメモリ上には可変長のエンコーディングであるUTF-8で格納される。

文字列を格納する型としては `String` が用いられ、これは `Vec<T>` に対応している。また、文字列のスライスは `&str` で表現される。

### 文字列型の使い分け

| 文字列の種類                                                                   | 可変長文字列型       | スライス |
| ------------------------------------------------------------------------------ | -------------------- | -------- |
| Unicode文字列                                                                  | `String`             | `&str`   |
| ファイル名                                                                     | `std::path::PathBuf` | `&Path`  |
| UTF-8でエンコードされていないバイナリデータ                                    | `Vec<u8>`            | `&[u8]`  |
| 環境変数名やコマンドライン引数などオペレーティングシステムのネイティブな文字列 | `OsString`           | `&OsStr` |
| null文字終端の文字列                                                           | `std::ffi::CString`  | `&Cstr`  |


## 型エイリアス

`type` キーワードを使って、既存の型に対して別の名前をつけることができる。

```rust
type Bytes = Vec<u8>;
```
